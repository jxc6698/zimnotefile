Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-02-20T15:02:25+08:00

====== 锁的理解 ======
Created Thursday 20 February 2014

seqlock
用于读多写少的时候，写操作的优先权大于读操作
维护一个  计数器  sequence 

写操作：开始时   sequence ++ ，结束时 sequence++ ；
使用另外一个互斥锁来保证写写互斥。

读操作：开始时  记录下当前 sequence 的值，如果是奇数（有写者正在执行），那就等待，结束时 比较当前的 sequence 的指与记录的值，如果不同那么就retry


优点：   读者不会阻塞写者


RCU

rcuclassic

rcupreempt

rcutree





读代码验证

一个进程如果从中断异常返回用户态时发现设置了NEED_RESCHED，就会被调度出去

中断异常结束时如果还是返回到内核态时不会触发调度的，所以才有了内核抢占，如果这个时候内核可以抢占，同时设置了NEED_RESCHED，这时就会把内核调度出去

在不能抢占的系统中，内核线程可以一直运行，直到结束。
抢占是从内核态到内核态发生的事情。
调度不一定会抢占，抢占则一定发生了调度。   ？ 什么意思，看不懂

内核抢占发生于
(1) 当"从中断处理程序"正在执行，且返回内核空间之前
    (2) 内核代码再一次具有可抢占性的时候
    (3) 如果内核中的任务显式的调用schedule()
    (4) 如果内核中的任务阻塞(这同样也会导致调用schedule())


